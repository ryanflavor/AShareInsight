"""Data fusion service for merging business concept information.

This service implements the smart fusion algorithm that merges new business
concept data with existing master data based on defined fusion rules.
"""

from datetime import UTC, datetime
from decimal import Decimal
from typing import Any
from uuid import UUID

import structlog

from src.domain.entities.business_concept_master import BusinessConceptMaster
from src.domain.entities.company import BusinessConcept

logger = structlog.get_logger(__name__)


class DataFusionService:
    """Service for merging business concept data using intelligent fusion rules."""

    def merge_business_concepts(
        self,
        existing: BusinessConceptMaster,
        new_concept: BusinessConcept,
        doc_id: UUID,
    ) -> BusinessConceptMaster:
        """Merge new business concept data into existing master record.

        Fusion rules:
        - Time-sensitive fields (overwrite): importance_score, development_stage,
          metrics, timeline
        - Cumulative fields (union): relations (customers, partners, subsidiaries)
        - Smart merge: description (keep longer/more detailed version)
        - Deduplication: source_sentences (union with limit)

        Args:
            existing: The existing BusinessConceptMaster record
            new_concept: The new BusinessConcept data to merge
            doc_id: The document ID providing the new data

        Returns:
            The updated BusinessConceptMaster with merged data
        """
        logger.info(
            "merging_business_concept",
            concept_id=str(existing.concept_id),
            concept_name=existing.concept_name,
            doc_id=str(doc_id),
        )

        # Prepare the new data dictionary
        new_data: dict[str, Any] = {
            "importance_score": new_concept.importance_score,
            "development_stage": new_concept.development_stage,
            "description": new_concept.description,
            "metrics": new_concept.metrics.model_dump() if new_concept.metrics else {},
            "timeline": new_concept.timeline.model_dump(),
            "relations": new_concept.relations.model_dump(),
            "source_sentences": new_concept.source_sentences,
        }

        # Use the entity's update method
        existing.update_from_fusion(new_data, doc_id)

        logger.info(
            "business_concept_merged",
            concept_id=str(existing.concept_id),
            new_version=existing.version,
            fields_updated=self._get_updated_fields(new_data),
        )

        return existing

    def create_from_new_concept(
        self,
        new_concept: BusinessConcept,
        company_code: str,
        doc_id: UUID,
    ) -> BusinessConceptMaster:
        """Create a new BusinessConceptMaster from a BusinessConcept.

        Args:
            new_concept: The BusinessConcept to create from
            company_code: The company code
            doc_id: The document ID providing the data

        Returns:
            A new BusinessConceptMaster instance
        """
        concept_details: dict[str, Any] = {
            "description": new_concept.description,
            "metrics": new_concept.metrics.model_dump() if new_concept.metrics else {},
            "timeline": new_concept.timeline.model_dump(),
            "relations": new_concept.relations.model_dump(),
            "source_sentences": new_concept.source_sentences,
        }

        return BusinessConceptMaster(
            concept_id=UUID(
                "00000000-0000-0000-0000-000000000000"
            ),  # Will be generated by DB
            company_code=company_code,
            concept_name=new_concept.concept_name,
            concept_category=new_concept.concept_category,
            importance_score=Decimal(str(new_concept.importance_score)),
            development_stage=new_concept.development_stage,
            embedding=None,  # To be populated by vectorization service
            concept_details=concept_details,
            last_updated_from_doc_id=doc_id,
            version=1,
            is_active=True,
            created_at=datetime.now(UTC),
            updated_at=datetime.now(UTC),
        )

    def _get_updated_fields(self, new_data: dict[str, Any]) -> list[str]:
        """Get list of fields that were updated.

        Args:
            new_data: The new data dictionary

        Returns:
            List of field names that were updated
        """
        updated_fields = []

        # Check which fields have non-empty values
        if new_data.get("importance_score") is not None:
            updated_fields.append("importance_score")

        if new_data.get("development_stage"):
            updated_fields.append("development_stage")

        if new_data.get("metrics") and any(new_data["metrics"].values()):
            updated_fields.append("metrics")

        if new_data.get("timeline") and any(new_data["timeline"].values()):
            updated_fields.append("timeline")

        if new_data.get("relations"):
            relations = new_data["relations"]
            if (
                relations.get("customers")
                or relations.get("partners")
                or relations.get("subsidiaries_or_investees")
            ):
                updated_fields.append("relations")

        if new_data.get("description"):
            updated_fields.append("description")

        if new_data.get("source_sentences"):
            updated_fields.append("source_sentences")

        return updated_fields
